<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的第一个ARPG游戏</title>
    <!-- 引入 Tone.js 库用于音效 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #111;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            color: white;
            overflow: hidden;
        }
        canvas {
            background-color: #000;
            display: block;
            border: 2px solid #555;
            border-radius: 8px;
            max-width: 95vw;
            max-height: 95vh;
            object-fit: contain;
            cursor: crosshair; /* 更改光标以示游戏区域 */
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            line-height: 1.6;
            z-index: 10;
        }
        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(128, 0, 0, 0.9);
            padding: 40px 60px;
            border-radius: 12px;
            border: 3px solid #FF4500;
            font-size: 2em;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.8);
            display: none;
            z-index: 100;
        }
        /* 新增：胜利/错误/失败的样式调整 */
        .win-box {
            background-color: rgba(0, 100, 0, 0.9) !important;
            border: 3px solid #00FF00 !important;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.8) !important;
        }
        .error-box {
            background-color: rgba(150, 0, 0, 0.9) !important;
            border: 3px solid #FF0000 !important;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.8) !important;
        }
        /* 新增的重新开始按钮样式 */
        .restart-button {
            margin-top: 25px;
            padding: 12px 25px;
            font-size: 0.6em; /* 相对于父元素字体大小 */
            font-weight: bold;
            color: white;
            background-color: #4CAF50;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
        }
        .restart-button:hover {
            background-color: #45a049;
        }
        .restart-button:active {
            transform: scale(0.98);
        }
        .hp-bar-container {
            width: 100%;
            height: 5px;
            background-color: #333;
            border-radius: 2px;
            overflow: hidden;
            margin-top: -8px;
            margin-bottom: 3px;
        }
        .hp-bar {
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.1s;
        }
    </style>
</head>
<body>

    <!-- 游戏提示信息 -->
    <div id="controls">
        <p><strong>ARPG 控制面板 (对战模式):</strong></p>
        <p><strong>移动:</strong> W, A, S, D</p>
        <p><strong>普攻:</strong> E 键 (近战攻击)</p>
        <p><strong>技能:</strong> 空格键 (范围奥术冲击波)</p>
        <p><strong>玩家血量:</strong> <span id="playerHp">200</span> / 200</p>
    </div>

    <!-- 游戏画布 -->
    <canvas id="gameCanvas" width="960" height="540"></canvas>

    <!-- 游戏结束/胜利信息框 (已修改) -->
    <div id="messageBox" style="display:none;">
        <span id="endMessageText">游戏结束！</span>
        <button id="restartButton" class="restart-button">重新开始</button>
    </div>

    <script>
        // --- 1. 获取画布和上下文 ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const playerHpDisplay = document.getElementById('playerHp');
        const messageBox = document.getElementById('messageBox');
        // 新增 DOM 元素获取
        const endMessageText = document.getElementById('endMessageText'); 
        const restartButton = document.getElementById('restartButton');
        
        let gameState = 'playing'; // 'playing', 'gameOver', 'win', 'error'

        // --- 2. 图片资源加载 ---

        let images = {};
        const imageNames = ['background', 'player', 'enemy', 'boss', 'skill']; 
        
        // 你的本地图片路径
        const imagePaths = {
            background: 'ASSETS/backgroud.png', 
            player:     'ASSETS/player.png',     
            enemy:      'ASSETS/enemy.png',      
            boss:       'ASSETS/boss.png',       
            skill:      'ASSETS/skill.png' 
        };
        
        // 加载图片的功能
        function loadImages(callback) {
            let loadedCount = 0;
            imageNames.forEach(name => {
                images[name] = new Image();
                images[name].src = imagePaths[name];
                images[name].onload = () => {
                    loadedCount++;
                    if (loadedCount === imageNames.length) {
                        callback();
                    }
                };
                images[name].onerror = () => {
                    // 即使加载失败，也计数，确保游戏能开始
                    console.warn(`无法加载图片: ${imagePaths[name]}。将使用颜色填充替代。`);
                    loadedCount++;
                    if (loadedCount === imageNames.length) {
                        callback();
                    }
                }
            });
        }

        // --- 音效设置 (Tone.js) ---
        let playerSynth = null;
        let hitSynth = null;
        let bossSynth = null;
        let isAudioReady = false;

        function initializeAudio() {
            if (isAudioReady) return;
            try {
                Tone.start();
                playerSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.2 }
                }).toDestination();
                hitSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.05,
                    envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.4, attackCurve: "exponential" }
                }).toDestination();
                bossSynth = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.5 }
                }).toDestination();
                isAudioReady = true;
                console.log("音效系统已启用。");
            } catch (e) {
                console.error("初始化音频失败:", e);
            }
        }
        
        function playSound(type) {
            if (!isAudioReady) return;
            switch(type) {
                case 'player_attack':
                    playerSynth.triggerAttackRelease("C5", "16n"); 
                    break;
                case 'player_skill':
                    // 新技能音效：更强烈的和弦
                    playerSynth.triggerAttackRelease(["C5", "F5", "A5"], "4n"); 
                    break;
                case 'boss_attack':
                    bossSynth.triggerAttackRelease("G3", "16n");
                    break;
                case 'hit':
                    hitSynth.triggerAttackRelease("C3", "8n"); 
                    break;
                case 'game_over':
                    playerSynth.triggerAttackRelease(["C3", "C#3", "D3"], "1s");
                    break;
                case 'win':
                    playerSynth.triggerAttackRelease(["C5", "E5", "G5"], "1s");
                    break;
            }
        }

        // --- 辅助函数 ---

        function checkCollision(r1, r2) {
            return r1.x < r2.x + r2.width &&
                   r1.x + r1.width > r2.x &&
                   r1.y < r2.y + r2.height &&
                   r1.y + r1.height > r2.y;
        }

        function drawHealthBar(x, y, width, height, currentHp, maxHp, color) {
            const barWidth = width;
            const barHeight = height;
            const healthRatio = Math.max(0, currentHp / maxHp);

            ctx.fillStyle = '#333';
            ctx.fillRect(x, y, barWidth, barHeight);

            ctx.fillStyle = color;
            ctx.fillRect(x, y, barWidth * healthRatio, barHeight);

            ctx.strokeStyle = '#000';
            ctx.strokeRect(x, y, barWidth, barHeight);
        }

        // --- 3. 游戏对象及其属性 ---
        
        // 玩家 (Player)
        const player = {
            x: 100, 
            y: canvas.height - 70, 
            width: 50,
            height: 50,
            speed: 3, 
            maxHp: 200, 
            currentHp: 200, 
            attackPower: 10, 
            skillPower: 60, // 技能伤害大幅提高
            facing: 'right', 
            
            normalAttackCooldown: 200, 
            lastNormalAttackTime: 0,
            skillCooldown: 1500, // 技能冷却时间增加
            lastSkillTime: 0,
            
            // 施法状态属性 (新增)
            isCastingSkill: false, 
            castStartTime: 0,
            castDuration: 250, // 施法锁定时间（毫秒）
            
            draw: function() {
                // 确保尺寸有效才绘制
                if (this.width <= 0 || this.height <= 0) return; 

                // 施法时给玩家一个视觉提示
                if (this.isCastingSkill) {
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = 'purple';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.globalAlpha = 1.0;
                }

                if (images.player && images.player.complete && images.player.naturalHeight !== 0) {
                    ctx.drawImage(images.player, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = 'green';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            },
            move: function() {
                // 施法时不能移动
                if (this.isCastingSkill) return; 

                if (keys['w'] && this.y > 0) this.y -= this.speed;
                if (keys['s'] && this.y < canvas.height - this.height) this.y += this.speed;
                if (keys['a'] && this.x > 0) {
                    this.x -= this.speed;
                    this.facing = 'left'; 
                }
                if (keys['d'] && this.x < canvas.width - this.width) {
                    this.x += this.speed;
                    this.facing = 'right'; 
                }
            },
            drawHealthBar: function() {
                playerHpDisplay.textContent = Math.max(0, Math.floor(this.currentHp));
            }
        };

        // 近战攻击类型定义
        const MELEE_NORMAL_TYPE = { damage: player.attackPower, width: 60, height: 20, duration: 100, color: 'rgba(255, 255, 0, 0.7)', type: 'normal' };
        // 范围技能类型定义 (AoE)
        const MELEE_SKILL_TYPE = { 
            damage: player.skillPower, 
            width: 150, // 范围扩大
            height: 150, 
            duration: 100, // 持续时间很短，瞬发
            color: 'rgba(255, 0, 255, 0.7)', 
            type: 'skill',
            isAoE: true 
        };
        
        // Boss 投射物类型 (伤害降低)
        const BOSS_PROJECTILE_TYPE = { width: 20, height: 20, color: 'magenta', damage: 8, speed: 6, isPlayer: false };

        let meleeAttacks = []; 
        let projectiles = []; 

        function getMeleeAttackPosition(attackType) {
            // 此函数现在只用于普通近战攻击，技能攻击在 gameLoop 中单独处理
            let x, y;
            if (player.facing === 'right') {
                x = player.x + player.width;
            } else {
                x = player.x - attackType.width;
            }
            y = player.y + (player.height - attackType.height) / 2;
            return { x, y };
        }

        function fireNormalAttack() {
            // 施法时不能普攻
            if (player.isCastingSkill) return; 

            const now = Date.now();
            if (now - player.lastNormalAttackTime > player.normalAttackCooldown) {
                const pos = getMeleeAttackPosition(MELEE_NORMAL_TYPE);
                const attack = {
                    x: pos.x, 
                    y: pos.y,
                    ...MELEE_NORMAL_TYPE,
                    startTime: now,
                    hitEnemies: new Set(),
                };
                meleeAttacks.push(attack);
                player.lastNormalAttackTime = now;
                playSound('player_attack');
            }
        }
        
        function fireSkillAttack() {
            const now = Date.now();
            if (now - player.lastSkillTime > player.skillCooldown && !player.isCastingSkill) {
                // 玩家进入施法状态
                player.isCastingSkill = true;
                player.castStartTime = now;
                player.lastSkillTime = now;
                
                playSound('player_skill');
            }
        }

        // 敌人 (Enemy)
        let enemies = [];
        function createEnemy(x, y) {
            return {
                x: x,
                y: y,
                width: 40,
                height: 40,
                speed: 2,
                maxHp: 50,
                currentHp: 50,
                isDead: false,
                draw: function() {
                    drawHealthBar(this.x, this.y - 10, this.width, 4, this.currentHp, this.maxHp, 'red');
                    if (images.enemy && images.enemy.complete && images.enemy.naturalHeight !== 0) {
                        ctx.drawImage(images.enemy, this.x, this.y, this.width, this.height);
                    } else {
                        ctx.fillStyle = 'red';
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                    }
                },
                update: function() {
                    // 简单追踪逻辑
                    if (this.x < player.x) {
                        this.x += this.speed * 0.5; 
                    } else if (this.x > player.x) {
                        this.x -= this.speed * 0.5;
                    }
                    
                    if (this.y < player.y) this.y += 0.5;
                    else if (this.y > player.y) this.y -= 0.5;
                    
                    // 限制在屏幕内
                    this.x = Math.max(0, Math.min(this.x, canvas.width - this.width));
                    this.y = Math.max(0, Math.min(this.y, canvas.height - this.height));
                }
            };
        }
        
        // Boss (Boss)
        const boss = {
            x: canvas.width - 150, 
            y: canvas.height / 2 - 75, 
            width: 150,
            height: 150,
            maxHp: 500,
            currentHp: 500,
            isDead: false, // 核心属性
            speed: 1, 
            moveDirection: -1, 
            fireRate: 150, 
            fireTimer: 0,
            draw: function() {
                drawHealthBar(this.x, this.y - 10, this.width, 8, this.currentHp, this.maxHp, 'gold');
                if (images.boss && images.boss.complete && images.boss.naturalHeight !== 0) {
                    ctx.drawImage(images.boss, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = 'purple';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            },
            update: function() {
                this.x += this.speed * this.moveDirection;
                if (this.x > canvas.width - this.width || this.x < 0) {
                    this.moveDirection *= -1;
                }
            }
        };

        // Boss 发射子弹
        function fireBossProjectile() {
            if (boss.isDead) return;
            
            const projectile = {
                x: boss.x + boss.width / 2 - BOSS_PROJECTILE_TYPE.width / 2,
                y: boss.y + boss.height / 2, 
                ...BOSS_PROJECTILE_TYPE
            };
            const angle = Math.atan2(player.y - projectile.y, player.x - projectile.x);
            projectile.vx = Math.cos(angle) * projectile.speed;
            projectile.vy = Math.sin(angle) * projectile.speed;
            
            projectiles.push(projectile);
            playSound('boss_attack');
        }


        // --- 4. 键盘输入控制 ---
        let keys = {}; 
        window.addEventListener('keydown', (e) => {
            if (gameState !== 'playing') return;
            keys[e.key.toLowerCase()] = true;
            
            if (e.key.toLowerCase() === 'e') {
                e.preventDefault();
                fireNormalAttack();
            }
            
            if (e.key === ' ') {
                e.preventDefault(); 
                fireSkillAttack();
            }
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        canvas.addEventListener('click', initializeAudio, { once: true });


        // --- 5. 游戏主循环 (Game Loop) ---
        function gameLoop() {
            if (gameState !== 'playing') {
                return; 
            }

            try { 
                
                // 1. 清除画布 & 绘制背景
                if (images.background && images.background.complete && images.background.naturalHeight !== 0) {
                    ctx.drawImage(images.background, 0, 0, canvas.width, canvas.height);
                } else {
                    ctx.fillStyle = '#222';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                // 2. 更新对象
                
                // 【新技能逻辑】处理施法和释放
                if (player.isCastingSkill) {
                    const now = Date.now();
                    if (now - player.castStartTime > player.castDuration) {
                        // 施法结束，释放AoE冲击波
                        player.isCastingSkill = false;
                        
                        // 冲击波以玩家为中心生成
                        const AoE_attack = {
                            x: player.x + player.width/2 - MELEE_SKILL_TYPE.width/2, 
                            y: player.y + player.height/2 - MELEE_SKILL_TYPE.height/2, 
                            ...MELEE_SKILL_TYPE,
                            startTime: now,
                            duration: MELEE_SKILL_TYPE.duration,
                            hitEnemies: new Set(),
                        };
                        meleeAttacks.push(AoE_attack);
                    }
                }

                player.move();
                
                // Boss 移动和攻击计时 - 只有 Boss 活着才更新
                if (!boss.isDead) {
                    boss.update(); 
                    boss.fireTimer++;
                    if (boss.fireTimer > boss.fireRate) {
                        fireBossProjectile();
                        boss.fireTimer = 0;
                    }
                }
                
                // 更新 Boss 投射物
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    if (p.y < -p.height || p.y > canvas.height || p.x < -p.width || p.x > canvas.width) {
                        projectiles.splice(i, 1);
                    }
                }
                
                // 更新玩家近战攻击判定框
                for (let i = meleeAttacks.length - 1; i >= 0; i--) {
                    const attack = meleeAttacks[i];
                    
                    if (Date.now() - attack.startTime > attack.duration) {
                        meleeAttacks.splice(i, 1);
                    } else if (attack.isAoE) {
                        // AoE 技能始终以玩家中心为判定中心
                        attack.x = player.x + player.width/2 - attack.width/2;
                        attack.y = player.y + player.height/2 - attack.height/2;
                    } else {
                        // 普通攻击根据朝向更新
                        const pos = getMeleeAttackPosition(attack);
                        attack.x = pos.x;
                        attack.y = pos.y;
                    }
                }

                enemies.forEach(e => e.update());
                // 移除已死亡的敌人 (只处理小怪)
                enemies = enemies.filter(e => !e.isDead);


                // 3. 碰撞和伤害检测
                
                // 3a. 玩家近战攻击 vs 敌人/Boss
                for (let i = meleeAttacks.length - 1; i >= 0; i--) {
                    const attack = meleeAttacks[i];
                    
                    // 击中 Boss
                    if (!boss.isDead && checkCollision(attack, boss) && !attack.hitEnemies.has(boss)) {
                        boss.currentHp -= attack.damage;
                        attack.hitEnemies.add(boss); 
                        playSound('hit');
                        
                        if (boss.currentHp <= 0) {
                            boss.isDead = true;
                        }
                    } 
                    
                    // 击中 小怪
                    enemies.forEach(e => {
                        if (checkCollision(attack, e) && !attack.hitEnemies.has(e)) {
                            e.currentHp -= attack.damage;
                            attack.hitEnemies.add(e); 
                            if (e.currentHp <= 0) {
                                e.isDead = true;
                            }
                            playSound('hit');
                        }
                    });
                }
                
                // 3b. 敌人/Boss 攻击 vs 玩家 (受到伤害)
                
                // Boss 投射物 vs 玩家
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    if (checkCollision(p, player)) {
                        player.currentHp -= p.damage;
                        projectiles.splice(i, 1); 
                        playSound('hit');
                    }
                }
                
                // 小怪碰撞 vs 玩家 (持续伤害)
                enemies.forEach(e => {
                    // 只有活着的小怪才会造成伤害
                    if (!e.isDead && checkCollision(e, player)) { 
                        player.currentHp -= 0.03; 
                    }
                });
                
                // 4. 绘制对象
                
                // 绘制近战攻击的临时视觉效果
                meleeAttacks.forEach(attack => {
                    ctx.globalAlpha = 0.6;
                    
                    // 【新技能绘制】AoE 冲击波使用不同的视觉效果
                    if (attack.type === 'skill' && attack.isAoE) {
                        ctx.globalAlpha = 0.8 * (1 - (Date.now() - attack.startTime) / attack.duration); // 绘制时逐渐透明
                        
                        // 绘制圆形的 AoE 效果
                        ctx.fillStyle = attack.color;
                        ctx.beginPath();
                        ctx.arc(attack.x + attack.width/2, attack.y + attack.height/2, attack.width/2, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.closePath();

                    } else if (attack.type === 'skill' && images.skill && images.skill.complete && images.skill.naturalHeight !== 0) {
                        // 绘制旧技能图片（如果 AoE 被禁用且图片存在）
                        ctx.globalAlpha = 0.8; 
                        ctx.drawImage(images.skill, attack.x, attack.y, attack.width, attack.height);
                    } else {
                        // 绘制普通攻击（或技能图片加载失败时的后备方案）
                        ctx.fillStyle = attack.color;
                        ctx.fillRect(attack.x, attack.y, attack.width, attack.height);
                    }
                    ctx.globalAlpha = 1.0; 
                });

                // 绘制 Boss 
                if (!boss.isDead) {
                    boss.draw();
                }
                
                // 绘制小怪
                enemies.forEach(e => e.draw());
                
                // 绘制玩家
                player.draw();
                player.drawHealthBar(); 
                
                // 绘制所有 Boss 投射物
                projectiles.forEach(p => {
                    ctx.fillStyle = p.color || 'white'; 
                    ctx.fillRect(p.x, p.y, p.width, p.height);
                });

                // 5. 游戏状态检查
                // 失败条件: 玩家血量归零
                if (player.currentHp <= 0) {
                    endGame('你被击败了！', 'gameOver');
                    playSound('game_over');
                    return; // 立即停止循环
                // 胜利条件: Boss已死亡 AND 所有小怪已清空
                } else if (boss.isDead && enemies.length === 0) { 
                    endGame('胜利！你拯救了世界！', 'win');
                    playSound('win');
                    return; // 立即停止循环
                }

                // 6. 循环调用
                requestAnimationFrame(gameLoop);

            } catch (error) {
                // 捕获任何未预期的错误，安全停止游戏循环并通知用户
                console.error("游戏循环中发生致命错误，游戏停止:", error);
                endGame('致命错误！请点击“重新开始”或刷新页面。', 'error');
            }
        }
        
        // 修正 endGame 函数，增加状态参数以切换样式
        function endGame(message, status) {
            gameState = status; // 可能是 'gameOver', 'win', 或 'error'
            endMessageText.textContent = message; 

            // 根据状态调整消息框样式
            messageBox.classList.remove('win-box', 'error-box');
            if (status === 'win') {
                messageBox.classList.add('win-box');
            } else if (status === 'error') {
                 messageBox.classList.add('error-box');
            }
            
            messageBox.style.display = 'block';
        }
        
        // --- 6. 重新开始游戏函数 (新增) ---
        function restartGame() {
            // 1. 重置游戏状态
            gameState = 'playing';

            // 2. 重置玩家属性和位置
            player.currentHp = player.maxHp;
            player.x = 100; 
            player.y = canvas.height - player.height - 20; 
            player.isCastingSkill = false; // 重置施法状态
            
            // 3. 重置 Boss 属性和位置
            boss.currentHp = boss.maxHp;
            boss.isDead = false;
            boss.x = canvas.width - boss.width - 100; 
            boss.y = canvas.height / 2 - boss.height / 2;
            boss.fireTimer = 0;
            boss.moveDirection = -1; // 确保 Boss 重置移动方向

            // 4. 清理所有动态对象
            enemies = [];
            meleeAttacks = [];
            projectiles = [];
            
            // 5. 重新生成小怪
            spawnInitialEnemies();
            
            // 6. 隐藏信息框并清理样式
            messageBox.style.display = 'none';
            messageBox.classList.remove('win-box', 'error-box'); 
            player.drawHealthBar(); // 强制更新血量显示
            
            // 7. 重新启动游戏循环 (requestAnimationFrame 会在下次浏览器重绘时调用 gameLoop)
            gameLoop();
        }


        // --- 7. 开始游戏 ---
        function spawnInitialEnemies() {
             enemies.push(createEnemy(100, 50));
             enemies.push(createEnemy(500, 100));
             enemies.push(createEnemy(800, 50));
             enemies.push(createEnemy(200, 10));
             enemies.push(createEnemy(700, 120));
        }

        console.log("正在加载图片...");
        loadImages(() => {
            console.log("图片加载完毕，游戏开始！");
            
            canvas.width = 960;
            canvas.height = 540;
            
            // 初始化位置
            player.x = 100; 
            player.y = canvas.height - player.height - 20; 
            boss.x = canvas.width - boss.width - 100; 
            boss.y = canvas.height / 2 - boss.height / 2; 

            spawnInitialEnemies();
            gameLoop(); // 启动游戏！
            
            // 绑定重新开始按钮的事件
            restartButton.addEventListener('click', restartGame);
        });

        function resizeCanvas() { }
        window.addEventListener('resize', resizeCanvas);

    </script>
</body>
</html>